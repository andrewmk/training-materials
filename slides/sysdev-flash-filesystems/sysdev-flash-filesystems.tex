\section{Using flash memories}

\begin{frame}
  \frametitle{Block devices vs flash devices}
  \begin{itemize}
  \item Block devices:
    \begin{itemize}
    \item Allow for random data access using fixed size blocks
    \item Do not require special care when writing on the media
    \item Block size is relatively small (minimum 512 bytes, can be
      increased for performance reasons)
    \item Considered as reliable (if the storage media is not, some
      hardware or software parts are supposed to make it reliable)
    \end{itemize}
  \item Flash devices:
    \begin{itemize}
    \item Allow for random data access too
    \item Require special care before writing on the media (erasing
      the region you are about to write on)
    \item Erase, write and read operation might not use the same block
      size
    \item Reliability depends on the flash technology
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{NAND flashes: how they work ?}
  \begin{itemize}
  \item Encode bits with Voltage levels
  \item Start with all bits set to 1
  \item Programming implies changing some bits from 1 to 0
  \item Restoring bits to 1 is done via the ERASE operation
  \item Programming and erasing is not done on a per bit or per byte
    basis
  \item Organization
    \begin{itemize}
    \item Page: minimum unit for PROGRAM operation
    \item Block: minimum unit for ERASE operation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{NAND flashes: organization}
  \begin{center}
    \includegraphics[scale=0.3]{slides/sysdev-flash-filesystems/nand-organization.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{NAND flashes: constraints}
  \begin{itemize}
  \item Reliability
    \begin{itemize}
    \item Far less reliable than NOR flashes
    \item Reliability depends on the NAND flash technology (SLC, MLC)
    \item Require additional mechanisms to correct errors: ECC (Error
       Corrector Code)
    \item ECC information stored in the OOB (Out-of-band area)
    \end{itemize}
  \item Lifetime
    \begin{itemize}
    \item Short lifetime compared to other storage media
    \item Lifetime depends on the NAND flash technology (SLC, MLC):
      between 1000000 and 1000 erase cycles per block
    \item Wear leveling mechanisms are required
    \item Bad block detection/handling required too
    \end{itemize}
  \item Despite the number of constraints brought by NAND they are
    widely used in embedded systems for several reasons:
    \begin{itemize}
    \item Cheaper than other flash technologies
    \item Provide high capacity storage
    \item Provide good performances (both in read and write access)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{NAND flashes: ECC}
  \begin{itemize}
  \item ECC partly address the reliability problem on NAND flashes
  \item Operates on blocks (usually 512 or 1024 bytes)
  \item ECC data are stored in the OOB area
  \item Three algorithms:
    \begin{itemize}
    \item Hamming: can fixup a single bit per block
    \item Reed-Solomon: can fixup several bits per block
    \item BCH: can fixup several bits per block
    \end{itemize}
  \item BCH and Reed-Solomon strengths depends on the size allocated
    for ECC data, which in turn depends on the OOB size
  \item NAND manufacturers specify the required ECC strength in their
    datasheets: ignoring these requirements might compromise data
    integrity
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The MTD subsystem (1)}
  \begin{itemize}
  \item MTD stands for {\em Memory Technology Devices}
  \item Generic subsystem dealing with all type of storage media that
    are not fitting in the block subsystem
  \item Supported media types: RAM, ROM, NORFLASH, NANDFLASH,
    DATAFLASH
  \item Independent of the communication interface (drivers available
    for parallel, SPI, direct memory mapping, ...)
  \item Abstract storage media characteristics and provide a simple
    API to access MTD devices
  \item MTD device characteristics exposed to users:
    \begin{itemize}
    \item \code{erasesize}: minimum erase size unit
    \item \code{writesize}: minimum write size unit
    \item \code{oobsize}: extra size to store metadata or ECC data
    \item \code{size}: device size
    \item \code{flags}: information about device type and capabilities
    \end{itemize}
  \item Various kind of MTD users: file-systems, block device emulation
    layers, userspace interfaces, ...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The MTD subsystem (2)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/mtd-architecture.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{MTD partitioning}
  \begin{itemize}
  \item MTD devices are usually partitioned
    \begin{itemize}
    \item It allows to use different areas of the flash for different
      purposes: read-only filesystem, read-write filesystem, backup
      areas, bootloader area, kernel area, etc.
    \end{itemize}
  \item Unlike block devices, which contains their own partition
    table, the partitioning of MTD devices is described externally
    \begin{itemize}
    \item Specified in the board Device Tree
    \item Hard-coded into the kernel code (if no Device Tree)
    \item Specified through the kernel command line
    \end{itemize}
  \item Each partition becomes a separate MTD device
    \begin{itemize}
    \item Different from block device labeling (\code{hda3},
      \code{sda2})
    \item \code{/dev/mtd1} is either the second partition of the first
      flash device, or the first partition of the second flash device
    \item Note that the master MTD device (the device those partitions
      belongs to) is not exposed in /dev
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: manipulating NAND devices}
  \begin{itemize}
  \item U-Boot provides a set of commands to manipulate NAND devices
  \item Grouped under the \code{nand} command
    \begin{itemize}
    \item \code{nand info}: show available NAND devices and their
      characteristics
    \item \code{nand device [dev]}: select or display the active NAND
      device
    \item \code{nand read[.option] <addr> <offset|part> <size>} read
      data from the NAND
    \item \code{nand write[.option] <addr> <offset|part> <size>} write
      data on the NAND
    \item Use \code{nand write.trimffs} to avoid writing empty pages
      (those filled with \code{0xff})
    \item \code{nand erase <offset> <size>} erase a NAND region
    \item \code{nand erase.part <part>} erase a NAND partition
    \item more commands for debugging purpose
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: manipulating NOR devices (1)}
  \begin{itemize}
  \item U-Boot provides a set of commands to manipulate NOR devices
  \item Memory mapped NOR devices
    \begin{itemize}
    \item \code{flinfo [devid]} display information of all NOR devices
      or a specific one if \code{devid} is provided
    \item \code{cp.[bwl] <src> <target> <count>} read/write data frm/to
      the NOR device
    \item \code{erase <start> <end>} or \code{erase <start> +<len>}
      erase a memory region
    \item \code{erase bank <bankid>} erase a memory bank
    \item \code{erase all} erase all banks
    \item \code{protect on|off <range-description>} protect a memory
      range
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: manipulating NOR devices (2)}
  \begin{itemize}
  \item SPI NOR devices
    \begin{itemize}
    \item Grouped under the \code{sf} command
    \item \code{sf probre [[bus:]cs] [hz] [mode]} probe a NOR device on
    \item \code{sf read|write <addr> <offset> <len>} read/write data
       from/to a SPI NOR
    \item \code{sf erase <offset> +<len>} erase a memory region
    \item \code{sf update <addr> <offset> <len>} erase + write operation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: using MTD partitions}
  \begin{itemize}
  \item U-Boot provides a way to define mtd partitions on top flash
    devices
  \item Using partitions ease manipulation of flash devices, which might
    be particularly error prone
  \item Requires two environment variables:
    \begin{itemize}
    \item \code{mtdids} attach an mtdid to a flash device.
      Example: \code{mtdids=<devid>=<mtdid>[,<devid>=<mtdid>]}
      \begin{itemize}
      \item \code{devid}: device identifier retrieved with
        \code{nand info} or \code{flinfo}
      \item \code{mtdid}: mtd identifier (should match linux MTD device
        name)
      \item \code{mtdid} is displayed when booting the linux kernel
      \end{itemize}
    \item \code{mtdparts} attach an mtdid to a flash device
    \end{itemize}
  \item Use the \code{mtdparts} command to setup the configuration
    specified by the \code{mtdids} and \code{mtdparts} variables
  \item Use flash specific commands (depends on your flash device type),
    and pass partition names instead of numerical offsets
  \item Example: \code{nand erase <partname>}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{U-Boot: defining MTD partitions (1)}
  \begin{itemize}
  \item \code{mtdparts} format: \code{<mtdid>:<partition>[,partition]}
  \item \code{partition} format: \code{<size>[@offset](<name>)[ro]}
  \item \code{mtdid} is the MTD device name assigned by linux
  \item \code{mtdid} is displayed at boot (and can be retrieved using
    \code{dmesg})
  \end{itemize}
\tiny
\begin{verbatim}
NAND device: Manufacturer ID: 0x2c, Chip ID: 0xbc (Micron NAND 512MiB 1,8V 16-bit)
Creating 5 MTD partitions on "omap2-nand.0":
0x000000000000-0x000000080000 : "X-Loader"
0x000000080000-0x000000200000 : "U-Boot"
0x000000200000-0x000000280000 : "Environment"
0x000000280000-0x000000580000 : "Kernel"
0x000000580000-0x000020000000 : "File System"
\end{verbatim}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: defining MTD partitions (2)}
  \begin{itemize}
  \item Example:\\
    \code{mtdparts=omap2-nand.0:512k(X-Loader)ro,1536k(U-Boot)ro,512k(Environment),4m(Kernel),16m(RootFS),-(Data)}
  \item We've just defined 6 partitions in the \code{omap2-nand.0} device:
    \begin{itemize}
    \item \code{1st stage bootloader} (512 KiB, read-only)
    \item \code{U-Boot} (1536 KiB, read-only)
    \item \code{U-Boot environment} (512 KiB)
    \item \code{Kernel} (4 MiB)
    \item \code{Root filesystem} (16 MiB)
    \item \code{Data filesystem} (Remaining space)
    \end{itemize}
  \item Partition sizes must be multiple of the erase block size.\\
    You can use sizes in hexadecimal too. Remember the below sizes:\\
    \code{0x20000} = 128k, \code{0x100000} = 1m, \code{0x1000000} = 16m
  \item \code{ro} lists the partition as read only
  \item \code{-} is used to use all the remaining space.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: MTD devices interface with userspace}
  \begin{itemize}
  \item MTD devices are visible in \code{/proc/mtd}
  \item The userspace only see MTD partitions, not the flash device
    under those partitions
  \item The {\bf mtdchar} driver creates a character device for each
    MTD device/partition of the system
    \begin{itemize}
    \item Usually named \code{/dev/mtdX} or \code{/dev/mtdXro}, major 90.
      Even minors for read-write access (\code{/dev/mtdX}),
      odd minors for read-only access (\code{/dev/mtdXro})
    \item Provide \code{ioctl()} to erase and manage the flash
    \item Used by the {\em mtd-utils} utilities
    \end{itemize}
  \item The {\bf mtdblock} driver creates a block device for each MTD
    device of the system
    \begin{itemize}
    \item Usually named \code{/dev/mtdblockX}, major 31. Minor is the
      number of the MTD device
    \item Allows read/write block-level access. But bad blocks are not
      handled, and no wear leveling is done for writes.
    \item Primary use: mounting read only block filesystems or JFFS2
    \item Do not write on mtdblock devices
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Linux: definition of MTD partitions (1)}
  The Device Tree is the standard place to device MTD partitions
  for boards with Device Tree support.\\
  Example from \code{arch/arm/boot/dts/omap3-igep0020.dts}:
\begin{minted}[fontsize=\scriptsize]{perl}
        nand@0,0 {
                linux,mtd-name= "micron,mt29c4g96maz";
		[...]
                partition@0 {
                        label = "SPL";
                        reg = <0 0x100000>;
                };
                partition@0x80000 {
                        label = "U-Boot";
                        reg = <0x100000 0x180000>;
                };
		[...]
                partition@0x780000 {
                        label = "Filesystem";
                        reg = <0x680000 0x1f980000>;
                };
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Linux: definition of MTD partitions (2)}
  For boards or platforms that do not use the Device Tree,
  MTD partitions can be defined in the kernel.
  Legacy example from \code{arch/arm/mach-omap2/board-igep0020.c}
  (removed in 3.13):
\begin{minted}[fontsize=\scriptsize]{c}
static struct mtd_partition igep2_flash_partitions[] = {
    {
        .name   = "X-Loader",
        .offset = 0,
        .size   = 2 * (64*(2*2048))
    },
    {
        .name   = "U-Boot",
        .offset = MTDPART_OFS_APPEND,
        .size   = 6 * (64*(2*2048)),
    },
    [...]
    {
        .name   = "File System",
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
    },
};
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Linux: modifying MTD partitions (1)}
  \begin{itemize}
  \item MTD partitions can fortunately be defined through the kernel
    command line.
  \item First need to find the name of the MTD device. Look at the
    kernel log at boot time. In the below example, the MTD device name is
    \code{omap2-nand.0}:
  \item U-Boot and linux are using the same syntax to describe the MTD
    partitions
  \item Directly pass the \code{mtdparts} environment variable defined in
    u-boot to the kernel cmdline
  \item Be careful: when modifying the partition layout you might impact
    MTD users which have already stored data on existing partitions: e.g.
    a file system might complain about data corruption if you change
    your partition layout after the file system initialization
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: modifying MTD partitions (3)}
  \begin{itemize}
  \item Partition sizes must be multiple of the erase block size.\\
    You can use sizes in hexadecimal too. Remember the below sizes:\\
    \code{0x20000} = 128k, \code{0x100000} = 1m, \code{0x1000000} = 16m
  \item \code{ro} lists the partition as read only
  \item \code{-} is used to use all the remaining space.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: userspace flash management tools}
  \begin{itemize}
  \item \code{mtd-utils} is a set of utilities to manipulate MTD devices
    \begin{itemize}
    \item \code{mtdinfo} to get detailed information about an MTD device
    \item \code{flash_erase} to partially or completely erase a given
      MTD device
    \item \code{flashcp} to write to NOR flash
    \item \code{nandwrite} to write to NAND flash
    \item Flash filesystem image creation tools: \code{mkfs.jffs2}
    \end{itemize}
  \item Usually available as the \code{mtd-utils} package in your distribution
  \item Most commands now also available in BusyBox
  \item See \url{http://www.linux-mtd.infradead.org/}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Flash wear leveling (1)}
  \begin{itemize}
  \item Wear leveling is about distributing write over the whole flash
    device to avoid quickly loosing blocks that are written really often
  \item Can be done in:
    \begin{itemize}
    \item the filesystem layer (JFFS2, YAFFS/YAFFS2, ...)
    \item an intermediate layer dedicated to wear leveling (UBI)
    \end{itemize}
  \item The wear leveling implementation is what makes your flash
    lifetime good or not
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash wear leveling (2)}
  \begin{itemize}
  \item Flash users should also take the limited lifetime of flash
    devices into account by taking additional precautions
    \begin{itemize}
    \item Do not use your flash storage as swap area (rare in embedded
      systems anyway)
    \item Mount your filesystems as read-only, or use read-only
      filesystems (SquashFS), whenever possible.
    \item Keep volatile files in RAM (tmpfs)
    \item Don't use the \code{sync} mount option (commits writes
      immediately). Use the \code{fsync()} system call for per-file
      synchronization.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash file-systems}
  \begin{itemize}
  \item 'Standard' file systems are meant to work on block devices
  \item Specific file systems have been developed to deal flash
    constraints
  \item These file systems are relying on the MTD layer to access
    flash chips
  \item There exists several legacy flash filesystems which might be
    useful for specific usage: JFFS2, YAFFS2, ...
  \item Nowadays, a lot of people are using UBI/UBIFS, and it is the
    de facto standard for medium to large capacity NANDs (128MB
    to several GB)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Legacy flash filesystems: JFFS2}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Supports on the fly compression
    \item Wear leveling, power failure resistant
    \item Boot time depends on the filesystem size (doesn't scale well)
    \item \url{http://www.linux-mtd.infradead.org/doc/jffs2.html}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/jffs2.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Legacy flash filesystems: YAFFS2}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Mainly supports NAND flash
    \item No compression
    \item Wear leveling, power failure resistant
    \item Fast boot time
    \item Code available separately through git\\
      (Dual GPL / Proprietary license\\
      for non Linux operating systems)
    \item \url{http://www.yaffs.net/}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/yaffs2.pdf}
  \end{columns}
\end{frame}


\begin{frame}
  \frametitle{UBI/UBIFS}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Aimed at replacing JFFS2 by addressing its limitations
    \item Design choices:
      \begin{itemize}
      \item Split the wear leveling and filesystem parts
      \item Add some flexibility
      \item Focus on scalability, performance and reliability
      \item Introduce noticeable overhead (especially when used on small
        devices or partitions)
      \end{itemize}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{UBI (1)}
  Unsorted Block Images
  \begin{itemize}
  \item \url{http://www.linux-mtd.infradead.org/doc/ubi.html}
  \item Volume management system on top of MTD devices (similar to
    what LVM provides for block devices)
  \item Allows to create multiple logical volumes and spread writes
    across all physical blocks
  \item Takes care of managing the erase blocks and wear
    leveling. Makes filesystems easier to implement
  \item Wear leveling can operate on the whole storage,
    not only on individual partitions (strong advantage)
  \item Volumes can be dynamically resized or, on the opposite, can be
    read-only (static)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI (2)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubi.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBI: internals}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{itemize}
    \item UBI is storing its metadata in-band
    \item In each MTD erase block
    \begin{itemize}
      \item One page is reserved to count the number of erase cycles
      \item Another page is reserved to attach the erase block to a
        UBI volume
      \item The remaining pages are used to store payload data
      \end{itemize}
    \item If the device supports subpage write, the EC and VID headers
      can be stored on the same page
    \end{itemize}
    \column{0.5\textwidth}
    \includegraphics[scale=0.3]{slides/sysdev-flash-filesystems/ubi-leb.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{UBI: good practice}
  \begin{itemize}
  \item UBI is responsible for distributing writes all over the flash
    device: the more space you assign to a partition attached to the
    UBI layer the more efficient the wear leveling will be
  \item If you need partitioning, use UBI volumes not MTD partitions
  \item Some partitions will still have to be MTD partitions: e.g. the
    bootloaders and bootloader environments
  \item If you need extra MTD partitions, try to group them at the end
    or the beginning of the flash device
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI layout: bad example}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs-bad-layout.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBI layout: good example}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs-good-layout.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBIFS}
  Unsorted Block Images File System
  \begin{itemize}
  \item \url{http://www.linux-mtd.infradead.org/doc/ubifs.html}
  \item The filesystem part of the UBI/UBIFS couple
  \item Works on top of UBI volumes
  \item Journaling file system providing better performances than
    JFFS2 and addressing its scalability issues
  \item See this paper for more technical details about UBIFS internals
    \url{http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: UBI host tools (1)}
  \begin{itemize}
  \item \code{ubinize} is the only host tool for the UBI layer
  \item Creates a UBI image to be flashed on an MTD partition
  \item Takes the following arguments:
    \begin{itemize}
    \item \code{-o <output-file-path>} path to the output image file
    \item \code{-p <peb-size>} the PEB size (MTD erase block size)
    \item \code{-m <min-io-size>} the minimum write unit size (e.g.
      MTD write size)
    \item \code{-s <subpage-size>} subpage size, only needed if both
      your flash and your flash controller are supporting subpage
      writes
    \item The last argument is a path to a UBI image description file
    \end{itemize}
  \item Example: \code{ubinize -o ubi.img -p 16KiB -m 512 -s 256 cfg.ini}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Linux: UBI host tools (2)}
  \begin{itemize}
  \item \code{ubinize} config file can contain several sections
  \item Each section is describing a UBI volume
  \item Example:
  \end{itemize}
  \begin{columns}
    \column{0.33\textwidth}
\small
\begin{verbatim}
[kernel-volume]
mode=ubi
image=zImage
vol_id=1
vol_type=static
vol_name=kernel
vol_alignment=1
\end{verbatim}
    \column{0.33\textwidth}
\small
\begin{verbatim}
[rootfs-volume]
mode=ubi
image=rootfs.squashfs
vol_id=1
vol_type=static
vol_name=rootfs
vol_alignment=1
\end{verbatim}
    \column{0.33\textwidth}
\small
\begin{verbatim}
[data-volume]
mode=ubi
image=data.ubifs
vol_id=1
vol_size=30MiB
vol_type=dynamic
vol_name=data
vol_flags=autoresize
vol_alignment=1
\end{verbatim}
  \end{columns}
  \begin{itemize}
  \item Build systems like Buildroot can run \code{ubinize} automatically!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{U-Boot: UBI tools}
  \begin{itemize}
  \item Grouped under the \code{ubi} command
    \begin{itemize}
    \item \code{ubi part <part-name>} attach an MTD partition to the UBI
      layer
    \item \code{ubi info [layout]} display UBI device information (or
      volume information if the \code{layout} string is passed
    \item \code{ubi check <vol-name>} check if a volume exists
    \item \code{ubi readvol <dest-addr> <vol-name> [<size>]} read volume
      content
    \item U-Boot also provides tools to update the UBI device content
    \item Using them is highly discouraged (the U-Boot UBI implementation
      is not entirely stable, and using commands that do not touch the UBI
      metadata is safer)
      \begin{itemize}
      \item \code{ubi createvol <vol-name> [<size>] [<type>]}
      \item \code{ubi removevol <vol-name>}
      \item \code{ubi writevol <src-addr> <vol-name> <size>}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: UBI target tools (1)}
  \begin{itemize}
  \item Tools used on the target to dynamically create and modify
      UBI elements
  \item UBI device management:
    \begin{itemize}
    \item \code{ubiformat <MTD-device-id>} format an MTD partition and
      preserve Erase Counter information if any
    \item \code{ubiattach -m <MTD-device-id> /dev/ubi_ctrl} attach an
      MTD partition/device to the UBI layer, and create a UBI device
    \item \code{ubidetach -m <MTD-device-id> /dev/ubi_ctrl} detach an
      MTD partition/device from the UBI layer, and remove this associated
      UBI device
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: UBI target tools (2)}
  \begin{itemize}
  \item UBI volume management:
    \begin{itemize}
    \item \code{ubimkvol /dev/ubi<UBI-device-id> -N <name> -s <size>} create
      a new volume. Use \code{-m} in place of \code{-s <size>} if you want
      to assign all the remaining to this volume
    \item \code{ubirmvol /dev/ubi<UBI-device-id> -N <name>} delete an UBI
      volume
    \item \code{ubiupdatevol /dev/ubi<UBI-device-id>_<UBI-vol-id> [-s <size>] <vol-image-file>}
      update volume content
    \item \code{ubirsvol /dev/ubi<UBI-device-id> -N <name> -s <size>}
      resize an UBI volume
    \item \code{ubirename /dev/ubi<UBI-device-id>_<UBI-vol-id> <old-name> <new-size>}
      rename a UBI volume
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: UBIFS host tools}
  \begin{itemize}
  \item UBIFS filesystems images can be created using the
    \code{mkfs.ubifs} utility
    \begin{itemize}
    \item \code{mkfs.ubifs -m 4096 -e 252KiB -c 1000 -r rootfs/ ubifs.img}
      \begin{itemize}
      \item \code{-m 4096}, minimal I/O size\\
                 (see \code{/sys/class/mtd/mtdx/writesize}).
      \item \code{-e 252KiB}, logical erase block size (smaller than
                 PEB size, look at \code{dmesg})
      \item \code{-c 1000}, maximum number of logical erase
        blocks. Details:
        {\tiny\url{http://linux-mtd.infradead.org/faq/ubifs.html\#L_max_leb_cnt}}
      \end{itemize}
    \item Once created
      \begin{itemize}
      \item Can be written to a UBI volume from the target using
        \code{ubiupdatevol}
      \item Or, can be included in a UBI image (using \code{ubinize}
        on the host)
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: flashing UBI/UBIFS howtos}
  \begin{itemize}
  \item See
    \url{http://free-electrons.com/blog/creating-flashing-ubi-ubifs-images/}
    for details about creating UBI and UBIFS images.
  \item See
    \url{http://www.linux-mtd.infradead.org/doc/ubi.html\#L_flasher_algo}
    for what is required when flashing UBI images.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: Booting a UBIFS filesystem as a rootfs}
  \begin{itemize}
  \item You just have to pass the following information on the kernel
    cmdline:
    \begin{itemize}
    \item \code{ubi.mtd=1}: attach /dev/mtd1 to the UBI layer and
      create ubi0
    \item \code{rootfstype=ubifs root=ubi0:rootfs}: mount the
      \code{rootfs} volume on ubi0 as a UBIFS filesystem
    \end{itemize}
  \item Example: \code{rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash filesystem benchmarks}
  \url{http://elinux.org/Flash_Filesystem_Benchmarks}
  \begin{itemize}
  \item {\bf jffs2}
    \begin{itemize}
    \item Worst performance
    \item Requires \code{CONFIG_SUMMARY} to have acceptable boot time
    \end{itemize}
  \item {\bf yaffs2}
    \begin{itemize}
    \item Good performance, but not in mainline Linux
    \end{itemize}
  \item {\bf ubifs}
    \begin{itemize}
    \item Best solution and performance for medium and big
      partitions
    \item Too much metadata overhead small partitions (only case
      when \code{yaffs2} and \code{jffs2} are still useful)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: Block emualtion layers}
  \begin{itemize}
  \item Sometimes we need block devices to re-use existing block
    filesystems
  \item Particularly useful for read-only block filesystems like squashfs
  \item Linux provides two block emulation layers:
    \begin{itemize}
    \item \code{mtdblock}: block devices emulated on top of MTD devices
    \item \code{ubiblock}: block devices emulated on top of UBI volumes
    \end{itemize}
  \item For read access, using emulated block devices is exactly the same
    as using regular
  \item Even if supported through the \code{mtdblock} emulation layer,
    writing on emulated block devices is highly discouraged (the emulation
    layer does not properly deal with wear leveling and data retention
    issues occurring on the flash media)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: mtdblock}
  \begin{itemize}
  \item The \code{mtdblock} layer creates a block device for each MTD
    device of the system
  \item Usually named \code{/dev/mtdblockX}, major 31. Minor is the
    number of the MTD device
  \item Allows read/write block-level access. But bad blocks are not
    handled, and no wear leveling is done for writes.
  \item For historical reasons JFFS2 filesystems require a block device
    to be mounted
  \item {\bf Do not write on mtdblock devices}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux: ubiblock}
  \begin{itemize}
  \item Preferred over \code{mtdblock} if UBI is available (UBI accounts
    for data retention and wear leveling issues, while MTD does not)
  \item The \code{ubiblock} layer creates {\bf read-only} block devices
    on demand
  \item The user specifies which static volumes he would like to attach
    to \code{ubiblock}
    \begin{itemize}
    \item Through the \code{cmdline}: by passing
      \code{ubi.block=<ubi-dev-id>,<volume-name>}
    \item Using the \code{ubiblock} utility provided by \code{mtd-utils}:
      \code{ubiblock --create <ubi-volume-dev-file>}
    \end{itemize}

   \item Usually named \code{/dev/ubiblockX_Y}, where X is the UBI device
     id and Y is the UBI volume id
   \item Major is dynamically assigned and stay the same for all
     \code{ubiblock} devices
   \item Minor is the id assigned to the \code{ubiblock} device (depends on
     the total number of \code{ubiblock} devices and the creation order).
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Useful reading}
  \begin{itemize}
  \item Managing flash storage with Linux:\\
    \url{http://free-electrons.com/blog/managing-flash-storage-with-linux/}
  \item Documentation on the linux-mtd website:\\
    \url{http://www.linux-mtd.infradead.org/}
  \end{itemize}
\end{frame}

\setuplabframe
{Flash Filesystems}
{
  \begin{itemize}
  \item Creating partitions in your internal flash storage
  \item Creating a UBI image with several volumes and flashing it from
    U-Boot
  \item Manipulating UBI volumes from linux
  \end{itemize}
}
