\section{Using flash memories}

\begin{frame}
  \frametitle{Block devices vs flash devices}
  \begin{itemize}
  \item Block devices:
    \begin{itemize}
    \item Allow for random data access using fixed size blocks
    \item Do not require special care when writing on the media
    \item Block size is relatively small (minimum 512 bytes, can be
      increased for performance reasons)
    \item Considered as reliable (if the storage media is not, some
      hardware or software parts are supposed to make it reliable)
    \item Used by the {\em mtd-utils} utilities
    \end{itemize}
  \item Flash devices:
    \begin{itemize}
    \item Allow for random data access too
    \item Require special care before writing on the media (erasing
      the region you are about to write on)
    \item Erase, write and read operation might not use the same block
      size
    \item Reliability depends on the flash technology
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{NAND flashes: how they work ?}
  \begin{itemize}
  \item Encode bits with Voltage levels
  \item Start with all bits set to 1
  \item Programming implies changing some bits from 1 to 0
  \item Restoring bits to 1 is done via the ERASE operation
  \item Programming and erasing is not done on a per bit or per byte
    basis
  \item Organization
    \begin{itemize}
    \item Page: minimum unit for PROGRAM operation
    \item Block: minimum unit for ERASE operation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{NAND flashes: organization}
  \begin{center}
    \includegraphics[scale=0.3]{slides/sysdev-flash-filesystems/nand-organization.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{NAND flashes: constraints}
  \begin{itemize}
  \item Reliability
    \begin{itemize}
    \item Far less reliable than NOR flashes
    \item Reliability depends on the NAND flash technology (SLC, MLC)
    \item Require additional mechanisms to correct errors: ECC (Error
       Corrector Code)
    \item ECC information stored in the OOB (Out-of-band area)
    \end{itemize}
  \item Lifetime
    \begin{itemize}
    \item Short lifetime compared to other storage media
    \item Lifetime depends on the NAND flash technology (SLC, MLC):
      between 1000000 and 1000 erase cycles per block
    \item Wear leveling mechanisms are required
    \item Bad block detection/handling required too
    \end{itemize}
  \item Despite the number of constraints brought by NAND they are
    widely used in embedded systems for several reasons:
    \begin{itemize}
    \item Cheaper than other flash technologies
    \item Provide high capacity storage
    \item Provide good performances (both in read and write access)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The MTD subsystem (1)}
  \begin{itemize}
  \item MTD stands for {\em Memory Technology Devices}
  \item Generic subsystem dealing with all type of storage media that
    are not fitting in the block subsystem
  \item Supported media types: RAM, ROM, NORFLASH, NANDFLASH,
    DATAFLASH
  \item Independent of the communication interface (drivers available
    for parallel, SPI, direct memory mapping, ...)
  \item Abstract storage media characteristics and provide a simple
    API to access MTD devices
  \item MTD device characteristics exposed to users:
    \begin{itemize}
    \item \code{erasesize}: minimum erase size unit
    \item \code{writesize}: minimum write size unit
    \item \code{oobsize}: extra size to store metadata or ECC data
    \item \code{size}: device size
    \item \code{flags}: information about device type and capabilities
    \end{itemize}
  \item Various kind of MTD users: file-systems, block device emulation
    layers, userspace interfaces, ...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The MTD subsystem (2)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/mtd-architecture.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{MTD devices: interface with userspace}
  \begin{itemize}
  \item MTD devices are visible in \code{/proc/mtd}
  \item The {\bf mtdchar} driver creates a character device for each
    MTD device of the system
    \begin{itemize}
    \item Usually named \code{/dev/mtdX} or \code{/dev/mtdXro}, major 90.
      Even minors for read-write access (\code{/dev/mtdX}),
      odd minors for read-only access (\code{/dev/mtdXro})
    \item Provide \code{ioctl()} to erase and manage the flash
    \item Used by the {\em mtd-utils} utilities
    \end{itemize}
  \item The {\bf mtdblock} driver creates a block device for each MTD
    device of the system
    \begin{itemize}
    \item Usually named \code{/dev/mtdblockX}, major 31. Minor is the
      number of the MTD device
    \item Allows read/write block-level access. But bad blocks are not
      handled, and no wear leveling is done for writes.
    \item Primary use: mounting filesystems
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{MTD partitioning}
  \begin{itemize}
  \item MTD devices are usually partitioned
    \begin{itemize}
    \item It allows to use different areas of the flash for different
      purposes: read-only filesystem, read-write filesystem, backup
      areas, bootloader area, kernel area, etc.
    \end{itemize}
  \item Unlike block devices, which contains their own partition
    table, the partitioning of MTD devices is described externally
    \begin{itemize}
    \item Specified in the board Device Tree
    \item Hard-coded into the kernel code (if no Device Tree)
    \item Specified through the kernel command line
    \end{itemize}
  \item Each partition becomes a separate MTD device
    \begin{itemize}
    \item Different from block device labeling (\code{hda3},
      \code{sda2})
    \item \code{/dev/mtd1} is either the second partition of the first
      flash device, or the first partition of the second flash device
    \item Note that the master MTD device (the device those partitions
      belongs to) is not exposed in /dev
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Definition of MTD partitions (1)}
  The Device Tree is the standard place to device MTD partitions
  for boards with Device Tree support.\\
  Example from \code{arch/arm/boot/dts/omap3-igep0020.dts}:
\begin{minted}[fontsize=\scriptsize]{perl}
        nand@0,0 {
                linux,mtd-name= "micron,mt29c4g96maz";
		[...]
                partition@0 {
                        label = "SPL";
                        reg = <0 0x100000>;
                };
                partition@0x80000 {
                        label = "U-Boot";
                        reg = <0x100000 0x180000>;
                };
		[...]
                partition@0x780000 {
                        label = "Filesystem";
                        reg = <0x680000 0x1f980000>;
                };
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Definition of MTD partitions (2)}
  For boards or platforms that do not use the Device Tree,
  MTD partitions can be defined in the kernel.
  Legacy example from \code{arch/arm/mach-omap2/board-igep0020.c}
  (removed in 3.13):
\begin{minted}[fontsize=\scriptsize]{c}
static struct mtd_partition igep2_flash_partitions[] = {
    {
        .name   = "X-Loader",
        .offset = 0,
        .size   = 2 * (64*(2*2048))
    },
    {
        .name   = "U-Boot",
        .offset = MTDPART_OFS_APPEND,
        .size   = 6 * (64*(2*2048)),
    },
    [...]
    {
        .name   = "File System",
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
    },
};
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modifying MTD partitions (1)}
  \begin{itemize}
  \item MTD partitions can fortunately be defined through the kernel
    command line.
  \item First need to find the name of the MTD device. Look at the
    kernel log at boot time. In the below example, the MTD device name is
    \code{omap2-nand.0}:
\end{itemize}
\tiny
\begin{verbatim}
NAND device: Manufacturer ID: 0x2c, Chip ID: 0xbc (Micron NAND 512MiB 1,8V 16-bit)
Creating 5 MTD partitions on "omap2-nand.0":
0x000000000000-0x000000080000 : "X-Loader"
0x000000080000-0x000000200000 : "U-Boot"
0x000000200000-0x000000280000 : "Environment"
0x000000280000-0x000000580000 : "Kernel"
0x000000580000-0x000020000000 : "File System"
\end{verbatim}
\end{frame}

\begin{frame}
  \frametitle{Modifying MTD partitions (2)}
  \begin{itemize}
  \item You can now use the \code{mtdparts} kernel boot parameter
  \item Example:\\
    \code{mtdparts=omap2-nand.0:512k(X-Loader)ro,1536k(U-Boot)ro,512k(Environment),4m(Kernel),16m(RootFS),-(Data)}
  \item We've just defined 6 partitions in the \code{omap2-nand.0} device:
    \begin{itemize}
    \item \code{1st stage bootloader} (512 KiB, read-only)
    \item \code{U-Boot} (1536 KiB, read-only)
    \item \code{U-Boot environment} (512 KiB)
    \item \code{Kernel} (4 MiB)
    \item \code{Root filesystem} (16 MiB)
    \item \code{Data filesystem} (Remaining space)
    \end{itemize}
  \item Be careful: when doing that you might impact MTD users which
    have already stored data on existing partitions: e.g. a file system
    might complain about data corruption if you change your partition
    layout after its initialization
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Modifying MTD partitions (3)}
  \begin{itemize}
  \item Partition sizes must be multiple of the erase block size.\\
    You can use sizes in hexadecimal too. Remember the below sizes:\\
    \code{0x20000} = 128k, \code{0x100000} = 1m, \code{0x1000000} = 16m
  \item \code{ro} lists the partition as read only
  \item \code{-} is used to use all the remaining space.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash wear leveling (1)}
  \begin{itemize}
  \item Wear leveling is about distributing write over the whole flash
    device to avoid quickly loosing blocks that are written really often
  \item Can be done in:
    \begin{itemize}
    \item the filesystem layer (JFFS2, YAFFS/YAFFS2, ...)
    \item an intermediate layer dedicated to wear leveling (UBI)
    \end{itemize}
  \item The wear leveling implementation is what makes your flash
    lifetime good or not
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash wear leveling (2)}
  \begin{itemize}
  \item Flash users should also take the limited lifetime of flash
    devices into account by taking additional precautions
    \begin{itemize}
    \item Do not use your flash storage as swap area (rare in embedded
      systems anyway)
    \item Mount your filesystems as read-only, or use read-only
      filesystems (SquashFS), whenever possible.
    \item Keep volatile files in RAM (tmpfs)
    \item Don't use the \code{sync} mount option (commits writes
      immediately). Use the \code{fsync()} system call for per-file
      synchronization.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash file-systems}
  \begin{itemize}
  \item 'Standard' file systems are meant to work on block devices
  \item Specific file systems have been developed to deal flash
    constraints
  \item These file systems are relying on the MTD layer to access
    flash chips
  \item There exists several legacy flash filesystems which might be
    useful for specific usage: JFFS2, YAFFS2, ...
  \item Nowadays, a lot of people are using UBI/UBIFS, and it is the
    de facto standard for medium to large capacity NANDs (128MB
    to several GB)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Legacy flash filesystems: JFFS2}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Supports on the fly compression
    \item Wear leveling, power failure resistant
    \item Boot time depends on the filesystem size (doesn't scale well)
    \item \url{http://www.linux-mtd.infradead.org/doc/jffs2.html}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/jffs2.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Legacy flash filesystems: YAFFS2}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Mainly supports NAND flash
    \item No compression
    \item Wear leveling, power failure resistant
    \item Fast boot time
    \item Code available separately through git\\
      (Dual GPL / Proprietary license\\
      for non Linux operating systems)
    \item \url{http://www.yaffs.net/}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/yaffs2.pdf}
  \end{columns}
\end{frame}


\begin{frame}
  \frametitle{UBI/UBIFS}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Aimed at replacing JFFS2 by addressing its limitations
    \item Design choices:
      \begin{itemize}
      \item Split the wear leveling and filesystem parts
      \item Add some flexibility
      \item Focus on scalability, performance and reliability
      \item Introduce noticeable overhead (especially when used on small
        devices or partitions)
      \end{itemize}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{UBI (1)}
  Unsorted Block Images
  \begin{itemize}
  \item \url{http://www.linux-mtd.infradead.org/doc/ubi.html}
  \item Volume management system on top of MTD devices (similar to
    what LVM provides for block devices)
  \item Allows to create multiple logical volumes and spread writes
    across all physical blocks
  \item Takes care of managing the erase blocks and wear
    leveling. Makes filesystems easier to implement
  \item Wear leveling can operate on the whole storage,
    not only on individual partitions (strong advantage)
  \item Volumes can be dynamically resized or, on the opposite, can be
    read-only (static)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI (2)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubi.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBI: good practice}
  \begin{itemize}
  \item UBI is responsible for distributing writes all over the flash
    device: the more space you assign to a partition attached to the
    UBI layer the more efficient the wear leveling will be
  \item If you need partitioning, use UBI volumes not MTD partitions
  \item Some partitions will still have to be MTD partitions: e.g. the
    bootloaders and bootloader environments
  \item If you need extra MTD partitions, try to group them at the end
    or the beginning of the flash device
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI layout: bad example}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs-bad-layout.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBI layout: good example}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-flash-filesystems/ubifs-good-layout.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{UBIFS}
  Unsorted Block Images File System
  \begin{itemize}
  \item \url{http://www.linux-mtd.infradead.org/doc/ubifs.html}
  \item The filesystem part of the UBI/UBIFS couple
  \item Works on top of UBI volumes
  \item Journaling file system providing better performances than
    JFFS2 and addressing its scalability issues
  \item See this paper for more technical details about UBIFS internals
    \url{http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{mtd-utils}
  \begin{itemize}
  \item A set of utilities to manipulate MTD devices
    \begin{itemize}
    \item \code{mtdinfo} to get detailed information about an MTD device
    \item \code{flash_erase} to partially or completely erase a given
      MTD device
    \item \code{flashcp} to write to NOR flash
    \item \code{nandwrite} to write to NAND flash
    \item UBI utilities
    \item Flash filesystem image creation tools: \code{mkfs.jffs2},
      \code{mkfs.ubifs}
    \end{itemize}
  \item Usually available as the \code{mtd-utils} package in your distribution
  \item Most commands now also available in BusyBox
  \item See \url{http://www.linux-mtd.infradead.org/}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI - Preparation}
  \begin{itemize}
  \item Have \code{/dev/} mounted as a \code{devtmpfs} filesystem
  \item Erase your flash partition while preserving your erase counters\\
    \code{ubiformat /dev/mtd1}\\
    See \url{http://www.linux-mtd.infradead.org/faq/ubi.html} if you
    face problems
  \item Attach UBI to one (of several) of the MTD partitions:\\
    \code{ubiattach /dev/ubi_ctrl -m 1}
  \item This command creates the \code{ubi0} device, which represent
    the full UBI space stored on MTD device 1 (new \code{/dev/ubi0}
    character device)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBI - Volume management}
  \begin{itemize}
  \item Volume creation with \code{ubimkvol}
    \begin{itemize}
    \item \code{ubimkvol /dev/ubi0 -N test -s 116MiB}
    \item \code{ubimkvol /dev/ubi0 -N test -m} (max available size)
    \item The volume is then identified as \code{ubi0:test} for the
      \code{mount}/\code{umount} commands
    \end{itemize}
  \item Volume removal with \code{ubirmvol}
    \begin{itemize}
    \item \code{ubirmvol /dev/ubi0 -N test}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBIFS - How to use}
  \begin{itemize}
  \item When a UBI volume is created, creating an empty UBIFS
    filesystem is just a matter of mounting it
    \begin{itemize}
    \item \code{mount -t ubifs ubi0:test /mnt/flash}
    \end{itemize}
  \item Images of UBIFS filesystems can be created using the
    \code{mkfs.ubifs} utility
    \begin{itemize}
    \item \code{mkfs.ubifs -m 4096 -e 252KiB -c 1000 -r rootfs/ ubifs.img}
      \begin{itemize}
      \item \code{-m 4096}, minimal I/O size\\
                 (see \code{/sys/class/mtd/mtdx/writesize}).
      \item \code{-e 252KiB}, logical erase block size (smaller than
                 PEB size, look at \code{dmesg})
      \item \code{-c 1000}, maximum number of logical erase
        blocks. Details:
        {\tiny\url{http://linux-mtd.infradead.org/faq/ubifs.html\#L_max_leb_cnt}}
      \end{itemize}
    \item Can be written to a UBI volume using \code{ubiupdatevol}: \\
      \code{ubiupdatevol /dev/ubi0_0 /path/to/ubifs.img}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ubinize (1)}
  After creating images of UBIFS filesystems, images of a full UBI space,
  containing several volumes, can be created using \code{ubinize}:
  \begin{itemize}
  \item Can be written to a raw MTD partition in U-boot.
  \item Must be written using \code{nand write.trimffs}.
  \item Caution: \code{nand erase} will also erase the Erase Counters
  \end{itemize}
  First, create a configuration file describing the UBI volumes (\code{ubi.ini}):
\small
\begin{verbatim}
[RFS-volume]
mode=ubi
image=rootfs.ubifs
vol_id=1
vol_size=30MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize
vol_alignment=1
\end{verbatim}
\end{frame}

\begin{frame}
  \frametitle{Ubinize (2)}
  \begin{itemize}
  \item \code{ubinize -o ubi.img -p 256KiB -m 4096 ubi.ini}
  \begin{itemize}
    \item Creates \code{ubi.img}, with 256KiB physical erase blocks,
      4096 minimum I/O size (\code{-m}).
  \end{itemize}
  \item See
    \url{http://free-electrons.com/blog/creating-flashing-ubi-ubifs-images/}
    for details about creating UBI and UBIFS images.
  \item See
    \url{http://www.linux-mtd.infradead.org/doc/ubi.html\#L_flasher_algo}
    for what is required when flashing UBI images containing UBIFS volumes.
  \item Build systems like Buildroot can run \code{ubinize} automatically!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{UBIFS - How to prepare a root fs}
  \begin{itemize}
  \item Create the UBIFS image for the root filesystem
  \item Create the UBI device image (with \code{ubinize})
  \item Flash it from the bootloader
  \item Pass UBI layout information to the kernel:
    \begin{itemize}
    \item \code{rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Flash filesystem benchmarks}
  \url{http://elinux.org/Flash_Filesystem_Benchmarks}
  \begin{itemize}
  \item {\bf jffs2}
    \begin{itemize}
    \item Worst performance
    \item Requires \code{CONFIG_SUMMARY} to have acceptable boot time
    \end{itemize}
  \item {\bf yaffs2}
    \begin{itemize}
    \item Good performance, but not in mainline Linux
    \end{itemize}
  \item {\bf ubifs}
    \begin{itemize}
    \item Best solution and performance for medium and big
      partitions
    \item Too much metadata overhead small partitions (only case
      when \code{yaffs2} and \code{jffs2} are still useful)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Issues with flash-based block storage}
  \begin{itemize}
  \item Flash storage made available only through a block interface.
  \item Hence, no way to access a low level flash interface
    and use the Linux filesystems doing wear leveling.
  \item No details about the layer (Flash Translation Layer) they
    use. Details are kept as trade secrets, and may hide poor
    implementations.
  \item Can use {\em flashbench}
        (\url{https://github.com/bradfa/flashbench}) to find out
        the erase block size and optimize filesystem formating.
  \item Not knowing about the wear leveling algorithm,
        it is highly recommended to limit the number of writes
        to these devices.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Useful reading}
  \begin{itemize}
  \item Arnd Bergmann: Optimizing Linux with cheap flash drives\\
    In depth coverage of flash storage with a block interface.\\
    \url{http://lwn.net/Articles/428584/}
  \item Managing flash storage with Linux:\\
    \url{http://free-electrons.com/blog/managing-flash-storage-with-linux/}
  \item Documentation on the linux-mtd website:\\
    \url{http://www.linux-mtd.infradead.org/}
  \end{itemize}
\end{frame}

\setuplabframe
{Flash Filesystems}
{
  \begin{itemize}
  \item Creating partitions in your internal flash storage
  \item Create a UBI image with several volumes and flash it from u-boot
  \item Manipulate UBI volumes from linux
  \end{itemize}
}
