\subchapter{Marvell Armada}{Objective: build and boot a mainline kernel}

During this lab, you will:

\begin{itemize}
\item Build a little endian mainline kernel and boot it on Armada 388 GP
\item Explore a few useful {\em debugfs} files
\item Build a big endian mainline kernel and boot it on Armada 388 GP
\end{itemize}

\section{Getting the kernel sources}

At the time of this writing, the support for the Armada 388 GP has not
yet landed in the mainline Linux kernel: it is only available in the
\code{linux-next} integration tree.

So, add the \code{linux-next} tree as a new {\em remote} in your
kernel Git repository:

\begin{verbatim}
git remote add linux-next git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git
\end{verbatim}

Then, fetch the contents of this repository:

\begin{verbatim}
git fetch linux-next
\end{verbatim}

Finally, switch to the \code{next-20150123} tag, which we have tested
to work:

\begin{verbatim}
git checkout next-20150123
\end{verbatim}

\section{Configuring the kernel}

Since we'll do both a little endian build and a big endian build,
we'll use out of tree build. This means we'll have one source tree,
and two separate build trees. Start by creating a build directory:

\begin{verbatim}
mkdir $HOME/felabs-kernel/mvebu-le
\end{verbatim}

And move to this directory.

We'll start with the \code{mvebu_v7_defconfig}, which is the reference
configuration for ARMv7 Marvell EBU platforms in the kernel (i.e
Armada 370, XP, 375, 38x and Dove) :

\begin{verbatim}
make -C $HOME/felabs-kernel/src O=$(pwd) ARCH=arm mvebu_v7_defconfig
\end{verbatim}

This command tells \code{make} to use the Makefile in
\code{$HOME/felabs-kernel/src}, but also tells the kernel that the
current directory (passed through \code{O=}) should be used as the
build tree. After this command has been executed, a small {\em
  wrapper} Makefile has been generated in the build directory, so we
don't have to pass \code{-C} and \code{O=} again.

We now need to refine the configuration, so run:

\begin{verbatim}
make ARCH=arm menuconfig
\end{verbatim}

We will have to:

\begin{itemize}
\item In {\em General setup} $\rightarrow$ {\em Initial RAM filesystem
    and RAM disk (initramfs/initrd) support} $\rightarrow$ {\em
    Initramfs source file(s)}, set the path to the pre-built {\em
    initramfs} we are providing. It is available in
  \code{$HOME/felabs-kernel/marvell-armada/rootfs.cpio.le}.
\item In {\em System Type}, explore the options available under {\em
    Marvell Engineering Business Unit (MVEBU) SoCs}
\item In {\em Kernel hacking}, enable the {\em Kernel low-level
    debugging functions} option. Then you should choose the right UART
  for the platform we're using. For Marvell EBU platforms, there are
  two options:
  \begin{itemize}
  \item {\em Kernel low-level debugging messages via MVEBU UART (old
      bootloaders)}, which uses the UART at physical address
    \code{0xd0012000}. This is what is used on old Armada 370/XP
    platforms where the bootloader was leaving the internal registers
    mapped at \code{0xd0000000}.
  \item {\em Kernel low-level debugging messages via MVEBU UART (new
      bootloaders)}, which uses the UART at physical address
    \code{0xf1012000}. This is what should be used with recent Armada
    370/XP platforms, and on all Armada 375/38x platforms. Therefore,
    select this choice.
  \end{itemize}
\item Still in {\em Kernel hacking}, make sure to enable {\em Early
    printk}.
\end{itemize}

\section{Building the kernel}

Now that the configuration is done, it's time to build the kernel:

\begin{verbatim}
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4
\end{verbatim}

The resulting files are:

\begin{itemize}
\item \code{arch/arm/boot/zImage}, the kernel image
\item \code{arch/arm/boot/dts/armada-388-gp.dtb}, the Device Tree blob
\end{itemize}

Copy those files to the directory exported on the network by your TFTP
server.

\section{Booting the kernel}

In U-Boot, adjust the \code{serverip} and \code{ipaddr} environment
variables to match your environment.

Then, define the kernel command line argument:

\begin{verbatim}
setenv bootargs console=ttyS0,115200 earlyprintk
\end{verbatim}

Load the kernel image in memory:

\begin{verbatim}
tftp 0x2100000 zImage
\end{verbatim}

Load the Device Tree blob in memory:

\begin{verbatim}
tftp 0x2000000 armada-388-gp.dtb
\end{verbatim}

And boot:

\begin{verbatim}
bootz 0x2100000 - 0x2000000
\end{verbatim}

At the end of the boot, the {\em Buildroot} login prompt should
appear. You can log in as root and start exploring the system.

\section{Exploring useful debugfs entries}

There are a few interesting things to look at in {\em debugfs}, so
we'll start by mounting debugfs:

\begin{verbatim}
mount -t debugfs none /sys/kernel/debug/
\end{verbatim}

Then, have a look at:

\begin{itemize}
\item \code{/sys/kernel/debug/mvebu-mbus/devices}, which contains a
  list of the CPU $\rightarrow$ devices MBus windows that are
  currently configured. You can see their base, size, MBus target ID
  and MBus attribute ID.
\item \code{/sys/kernel/debug/mvebu-mbus/sdram} contains the list of
  the CPU $\rightarrow$ memory MBus windows.
\item \code{/sys/kernel/debug/clk/clk_summary} contains the list of
  the clocks, whether they are enabled or not, and their current rate.
\item
  \code{/sys/kernel/debug/pinctrl/f1018000.pinctrl/pinconf-groups},
  and other files in
  \code{/sys/kernel/debug/pinctrl/f1018000.pinctrl/}, allows to
  explore the {\em pinctrl} configuration. On Marvell EBU platforms,
  this is used to configure the MPPs.
\item \code{/sys/kernel/irq_domain_mapping} to look at the virtual to
  physical IRQ mappings.
\end{itemize}

\section{Testing the big endian kernel}

Since the big endian kernel is completely different from the little
endian one in terms of generated code, we'll use a separate build
tree. Let's create it first:

\begin{verbatim}
mkdir $HOME/felabs-kernel/mvebu-be
\end{verbatim}

Go in this directory, and then copy the configuration file we have
created for the little endian build:

\begin{verbatim}
cp $HOME/felabs-kernel/mvebu-le/.config .config
\end{verbatim}

Now, we'll adjust the configuration:

\begin{verbatim}
make -C $HOME/felabs-kernel/src O=$(pwd) ARCH=arm menuconfig
\end{verbatim}

Note that since it's the first time we run a \code{make} command from
this build directory, we explicitly pass \code{-C} and \code{O=}, so
that the {\em wrapper} Makefile gets generated.

In the configuration, adjust the following items:

\begin{itemize}
\item Adjust the path of the {\em initramfs}, to point to
  \code{$HOME/felabs-kernel/marvell-armada/rootfs.cpio.be}, which
  contains a big endian userspace.
\item In {\em System type}, enable the {\em Build big-endian kernel}
  option.
\end{itemize}

Start the build of your kernel, generate the appended zImage, then the
uImage, and boot your kernel. You can verify with \code{uname} that
you are indeed running a \code{armv7b} system, i.e a big-endian ARM
system.
