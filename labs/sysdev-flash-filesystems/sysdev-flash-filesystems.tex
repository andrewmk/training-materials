\subchapter{Storage - Flash devices}{Objective: Understand flash and flash file systems usage and their integration on the target}

After this lab, you will be able to:
\begin{itemize}
\item Prepare filesystem images and flash them.
\item Define partitions in embedded flash storage.
\end{itemize}

\section{Setup}

Stay in \code{$HOME/embedded-linux-labs/tinysystem}. Install the
\code{mtd-utils} package, which will be useful to create UBIFS and
UBI images.

\section{Goals}

Instead of using an external MMC card as in the previous lab, we will
make our system use its internal flash storage.

Create an MTD partition to be attached to the UBI layer (the partitions
previously used to store the kernel image and the DTB should be merged
with this UBI partition).
Kernel and DTB images will should be stored in two separate static
(read-only) UBI volumes.
The root filesystem will be a UBIFS volume (still mounted in a read-only).
Read/write data will be stored in a UBIFS file system too.
As for the kernel and DTB images, the root and data filesystems will be
placed in a UBI volumes (this time we will use dynamic volumes).

Which gives the following layout:

\begin{center}
  \includegraphics[width=\textwidth]{labs/sysdev-flash-filesystems/flash-map.pdf}
\end{center}

\section{Enabling NAND flash and filesystems}

First, recompile your kernel with support for UBI and UBIFS, and enable
the option allowing us to pass the partition table through the cmdline:
(\code{CONFIG_MTD_CMDLINE_PARTS}).

Recompile your kernel, and we will update your kernel image on flash
in the next section.

\section{Filesystem image preparation}

Find the erase block size of the NAND flash device soldered on your
board.

Prepare a UBIFS filesystem image from the \code{/www/upload/files}
directory from the previous lab.

Now, we will get back to the root filesystem contents in the
\code{nfsroot} directory, and will generate a UBIFS image from them.

First enable the ubi tools in busybox (\code{ubiattach},
\code{ubidetach}, \code{ubimkvol}, ...), then recompile and reinstall
\code{busybox} in you rootfs directory.

Now, modify the \code{/etc/init.d/rcS} file to mount a UBIFS filesystem
on the \code{data} volume (we will declare UBI volumes in the next
section), instead of an ext3 filesystem on the third MMC disk partition.

Once done, create a UBIFS image for your root filesystem, with the same
options as for the data filesystem.

\section{UBI image preparation}

Create a ubinize config file where you will define the 4 volumes
described above, then use the \code{ubinize} tool to generate your
UBI image.
Warning: do not use the autoresize flag (\code{vol_flags=autoresize})
(U-Boot corrupts the UBI metadata when trying to resize expand the
volume).

Remember that some of these volumes are static (read-only) and some are
not.

%Creating UBIFS images:
%
%mkfs.ubifs -d <rootfs-directory-path> -o <rootfs-image-path> -e 124KiB -m 2048 -c 1024
%mkfs.ubifs -d <data-directory-path> -o <data-image-path> -e 124KiB -m 2048 -c 1024
%

%
% ubi config file content
%
%[kernel]
%mode=ubi
%image=<zImage-path>
%vol_id=1
%vol_type=static
%vol_name=kernel
%vol_alignment=1
%
%[dtb]
%mode=ubi
%image=<dtb-path>
%vol_id=2
%vol_type=static
%vol_name=dtb
%vol_alignment=1
%
%[root]
%mode=ubi
%image=<rootfs-image-path>
%vol_id=3
%vol_type=dynamic
%vol_size=10MiB
%vol_name=root
%vol_alignment=1
%
%[data]
%mode=ubi
%image=<data-image-path>
%vol_id=4
%vol_type=dynamic
%vol_name=data
%vol_alignment=1
%

%
% Creating UBI images:
%
% # ubinize -o test.ubi -p 128KiB -m 2048 ubi.ini 
%

\section{MTD partitioning and flashing}

Look at the way default flash partitions are defined in the board
Device Tree sources
(\code{arch/arm/boot/dts/at91-sama5d3_xplained.dts}).

However, they do not match the way we wish to organize our flash
storage. Therefore, we will define our own partitions at boot time,
on the kernel command line.

Redefine the partition in U-Boot using the \code{mtdids} and
\code{mtdparts} environment variables.
Once done, execute the \code{mtdparts} command and check the partition
definitions.

You can now safely erase the UBI partition without risking any
corruption on other partitions.

Download the UBI image (using \code{tftp}) you have created in the
previous section and flash it on the UBI partition.

When flashing the UBI image, use the \code{trimffs} version of the
command \code{nand write}.
\footnote{The command \code{nand write.trimffs} skips
  the blank sectors instead of writing them. It is needed because the
  algorithm used by the hardware ECC for the SAMA5D3 SoC generates a
  checksum with bytes different of 0xFF if the page is blank. Linux
  only checks the page, and if it is blank it doesn't erase it, but as
  the OOB is not blank it leads to ECC errors. More generally it is
  not recommended writing more than one time on a page and its OOB
  even if the page is blank.}

\section{Loading kernel and DTB images from UBI and booting it}

Attach the UBI partition to the UBI layer and verify that all the
UBI volumes are present.

Now, retrieve the kernel and DTB images from their respective UBI
volumes and try to boot them. If it works, you can modify your
\code{bootcmd} accordingly.


Don't forget that you can write U-Boot scripts to automate these
procedures. This is very handy to avoid mistakes when typing commands!

Set the \code{bootargs} variable so that:

\begin{itemize}
\item The \code{mtdparts} environment variable content is passed to
  the kernel through cmdline
\item The UBI partition is automatically attached to the UBI layer at
  boot time
\item The root filesystem is mounted from the 7\textsuperscript{th}
  partition, and is mounted read-only (kernel parameter
  \code{ro}).
  \begin{itemize}
  \item \bf{Important: even if this partition is mounted read-only,
      the MTD partition itself must be declared as read-write.
      Otherwise, Linux won't be able to perform ECC checks on it,
      which involve both reading and writing.}
  \end{itemize}
\end{itemize}

Boot the target, check that MTD partitions and UBI volumes are correctly
configured, and that your system still works as expected. Your root
filesystem should be mounted read-only, while the data filesystem should
be mounted read-write, allowing you to upload data using the web server.

%Useful u-boot environment variables
%mtdids=nand0=atmel_nand
%mtdparts=mtdparts=atmel_nand:256k(bootstrap),512k(u-boot),256k(u-boot-env1),256k(u-boot-env2),-(UBI)
%bootargs_base=console=ttyS0,115200 rootfstype=ubifs root=ubi0:root ip=dhcp ubi.mtd=4 rw
%bootcmd=mtdparts; ubi part UBI; ubi readvol 0x21000000 kernel; ubi readvol 0x22000000 dtb; setenv bootargs $bootargs_base $mtdparts; bootz 0x21000000 - 0x22000000
%flash=mtdparts; nand erase.part UBI; tftp 0x21000000 test.ubi; nand write.trimffs 0x21000000 UBI $filesize

\section{Resizing an existing volume and creating a new one}

In some cases you might want to adpat your NAND partitioning without
re-flashing everything. Thanks to UBI this is possible.

Resize the \code{data} volume to occupy the remaining 50MiB.

Create a new \code{log} volume of 16MiB
Mount this volume as a UBIFS filesystem and see what happens.

Update your init script to mount the UBI \code{log} volume on /var/log.
Reboot your system and check that the \code{log} is correcly mounted.

% Hints:
%
%ubirsvol /dev/ubi0 -n 4 -s 50MiB
%ubimkvol /dev/ubi0 -N log -s 16MiB
%mount -t ubifs ubi0:log /var/log
%


\section{Going further}

UBI also provides an atomic update feature, which is particularly useful
if you need to safely upgrade sensitive parts of your system (kernel,
DTB or rootfs).

Duplicate the kernel volume and create a U-Boot script to fallback on
the second kernel volume if the first one is corrupted:
\begin{itemize}
  \item First create a new static volume to store your kernel backup
  \item Flash a valid kernel on the backup volume
  \item Modify your bootcmd to fallback to the backup volume if the first one
    is corrupted
  \item Now try to update the kernel volume and interrupt the process before
    it has finished and see what happens (unplug the platform)
  \item Create a shell script to automate kernel updates (executed in Linux).
    Be careful, this script should also handle the case where the backup
    volume has been corrupted (copy the content of the kernel volume into
    the backup one)
\end{itemize}

%TODO: provide a correction

\section{Going even further}

Root filesystems are often a sensitive part of your system, and you don't
want it to be corrupted, hence some people decide to use read-only
file system for their rootfs and use another file system to store their
auxiliary data.

\code{squashfs} is one of these read-only file systems, the problem is:
it expects to be mounted on a block device.

Use the ubiblk layer to emulate a read-only block device on top of a static
UBI volume to mount a rootfs squashfs filesystem:
\begin{itemize}
  \item First Create a squashfs image with your rootfs content
  \item Then create a new static volume to store your squashfs and update it with
    your squashfs image
  \item Enable and setup the ubiblk layer
  \item Boot on your new rootfs
\end{itemize}

%TODO: provide a correction

